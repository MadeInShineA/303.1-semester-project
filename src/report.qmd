---
title: "Implementation Report: Predict Function"
number-sections: true
---

## Introduction

This report provides an overview of the implemented prediction functions in DIPY's Generalized Q-Sampling Imaging (GQI) model, covering their purpose, operational mechanics, mathematical foundations, testing methodology, capabilities, and future directions.

Key topics include:

- Functionality and operation of the GQI prediction functions (`gqi_kernel`, `prediction_kernel`, and `predict`)
- Mathematical derivations and pseudo-inverse computations
- Testing procedures applied to the functions
- Enabled applications and subsequent development steps

---

## The different needed helper functions
The `predict` function implementation relies on two key helper functions:

  - `gqi_kernel` for kernel computation
  - `prediction_kernel` for pseudo-inverse calculation.

In this section, each function is described in detail, including its purpose, parameters, and role in signal reconstruction from ODFs.

### The `gqi_kernel` function
The `gqi_kernel` function calculates the Generalized Q-Sampling Imaging (GQI) transformation kernel, which is essential for modeling diffusion signals in terms of orientation distribution functions (ODFs). This kernel transforms gradient directions and b-values into a matrix that relates diffusion signals to ODFs on a spherical grid.

- **Purpose**: Computes the kernel matrix for GQI-based signal reconstruction. It handles different GQI methods (e.g., "standard" or "gqi2") and incorporates physical constants like the free water diffusion coefficient.
- **Key Parameters**:
  - `gtab`: GradientTable containing b-values and b-vectors.
  - `param_lambda`: Regularization parameter for the kernel.
  - `sphere`: Spherical grid for ODF sampling.
  - `method`: Specifies the GQI variant ("standard" by default).
- **Operation**: Scales b-vectors by a diffusion-related factor, computes dot products with sphere vertices, and applies sinc or squared radial functions to generate the kernel.

```Python
def gqi_kernel(gtab, param_lambda, sphere, method="standard"):
    # 0.01506 = 6*D where D is the free water diffusion coefficient
    # l_values sqrt(6 D tau) D free water diffusion coefficient and
    # tau included in the b-value
    scaling = np.sqrt(gtab.bvals * 0.01506)
    b_vector = gtab.bvecs * scaling[:, None]

    if method == "gqi2":
        H = squared_radial_component
        return np.real(H(np.dot(b_vector, sphere.vertices.T) * param_lambda))
    elif method != "standard":
        warnings.warn(
            f'GQI model "{method}" unknown, falling back to "standard".',
            stacklevel=1,
        )
    return np.real(np.sinc(np.dot(b_vector, sphere.vertices.T) * param_lambda / np.pi))
```

Mathematically, the GQI kernel $K$ is computed as:

For the "standard" method:
$$
K_{ij} = \frac{\sin\left( \lambda (\mathbf{q}_i \cdot \mathbf{v}_j) \right)}{\lambda (\mathbf{q}_i \cdot \mathbf{v}_j)} = \operatorname{sinc}\left( \frac{\lambda (\mathbf{q}_i \cdot \mathbf{v}_j)}{\pi} \right)
$$
Where:

  - $\mathbf{q}_i = \mathbf{g}_i \sqrt{b_i \cdot 0.01506}$ (scaled gradient)
  - $\mathbf{v}_j$ are sphere vertices
  - $\lambda$ is the regularization parameter
  - $\operatorname{sinc}(x) = \frac{\sin(\pi x)}{\pi x}$ is the NumPy's normalized `sinc` function.

For the "gqi2" method:
$$
K_{ij} = \operatorname{Re}\left[ H\left( \lambda (\mathbf{q}_i \cdot \mathbf{v}_j) \right) \right]
$$
Where $H$ is the squared radial component function.

### The `prediction_kernel` function
The `prediction_kernel` function computes the Tikhonov-regularized Moore-Penrose pseudo-inverse of the GQI kernel, enabling signal reconstruction from orientation distribution functions (ODFs) in the DIPY convention.

- **Purpose**: Generates the Tikhonov-regularized pseudo-inverse kernel for solving S from $ODF = S \cdot K$, using regularization for numerical stability.
- **Key Parameters**:
  - `gtab`: GradientTable for the prediction.
  - `param_lambda`: `gqi_kernel` regularization parameter.
  - `sphere`: Spherical grid.
  - `method`: GQI method.
- **Operation**: Computes the GQI kernel `K`, forms `K @ K.T`, adds regularization, inverts the matrix, and multiplies by `K.T` to produce the Moore-Penrose pseudo-inverse kernel.

```Python
def prediction_kernel(gtab, param_lambda, sphere, method="standard"):
    # K.shape = (n_gradients, n_vertices)
    K = gqi_kernel(gtab, param_lambda, sphere, method=method)

    # GTG.shape = (n_gradients, n_gradients)
    GtG = K @ K.T
    identity = np.eye(GtG.shape[0])

    # K_plus.shape = (n_vertices, n_gradients)
    return K.T @ np.linalg.inv(GtG + INVERSE_LAMBDA * identity)
```

Mathematically, the prediction kernel $K^{+}$ (the pseudo-inverse) is computed as:
$$
K^{+} = K^T (K K^T + \lambda I)^{-1}
$$
Where:

   - $K$ is the GQI kernel from `gqi_kernel`
   - $\lambda$ is the regularization parameter (`INVERSE_LAMBDA`)
   - $I$ is the identity matrix.

The Tikhonov regularization term ($\lambda I$) is added to improve numerical stability and prevent overfitting. The plain Moore-Penrose pseudo-inverse, computed as $K^T (K K^T)^{-1}$, can be unstable for ill-conditioned matrices, amplifying noise in the diffusion signals. Regularization provides a smoother, more robust solution by balancing fidelity to the data with stability.


## The `predict` function and it's implementation

The target predicted signal is given by the following relationship
   $$
   \begin{alignat*}{2}
             &ODF                      &&= S \cdot K \\
  \iff\quad & ODF \cdot K^{+}          &&\approx S \cdot K \cdot K^{+} \\
  \iff\quad & ODF \cdot K^{+}          &&\approx S \\
  \iff\quad & S                        &&\approx ODF \cdot K^{+}
  \end{alignat*}
  $$

Where $K^{+}$ is the Tikhonov-regularised Moore-Penrose pseudo-inverse of the GQI kernel $K$.

Note that the pseudo-inverse is needed since the GQI kernel $K$'s dimensions are $(n_\mathrm{gradients}, n_\mathrm{vertices})$, which means it's (most of the time) not a square matrix and therefore not having a true inverse.


The `predict` function reconstructs diffusion signals from the fitted signal data by first computing the ODF internally and then applying the pseudo-inverse kernel.

- **Purpose**: Predicts diffusion-weighted signals from fitted data, supporting both single-voxel and multi-voxel data.
- **Key Parameters**:
  - `gtab`: GradientTable for which to predict signals.
  - `S0`: Optional baseline signal (not used in this implementation).
- **Operation**: Fuses the model kernel and prediction kernel to avoid explicit $ODF$ computation: `combined_kernel` = $K_\mathrm{model}^T \cdot K^+$, then `predicted = data @ combined_kernel`. Handles data reshaping for matrix operations and ensures non-negative outputs by clamping values.
```Python
def predict(self, gtab, *, S0=None):
    # K_plus.shape = (n_vertices, n_gradients)
    K_plus = prediction_kernel(
        gtab,
        self.model.Lambda,
        self.model.sphere,
        self.model.method,
    )

    # Fuse kernel and prediction kernel to avoid explicit ODF computation:
    # combined_kernel.shape = (n_gradients_original, n_gradients)
    combined_kernel = self.model.kernel.T @ K_plus

    # Handle both 1D (single voxel) and multi-dimensional data
    if self.data.ndim == 1:
        # Single voxel: data = (self.model.n_gradients,)

        # predicted.shape = (n_gradients, )
        predicted = self.data @ combined_kernel
    else:
        # Multi-voxel: data = (..., self.model.n_gradients)
        original_shape = self.data.shape
        data_2d = self.data.reshape(-1, original_shape[-1])

        # predicted_2d.shape = (n_voxels, n_gradients)
        predicted_2d = data_2d @ combined_kernel

        # predicted.shape = (..., n_gradients)
        predicted = predicted_2d.reshape(
            original_shape[:-1] + (combined_kernel.shape[1],)
        )

    # Clamp to non-negative values
    return np.maximum(predicted, 0)
```


Mathematically, the predicted signal $\mathbf{S}_\mathrm{pred}$ is computed as:
$$
\mathbf{S}_\mathrm{pred} = \max(0, \mathrm{ODF} \cdot K^{+})
$$
Where:

- $\mathrm{ODF} = K_\mathrm{model} \cdot \mathbf{S}_\mathrm{data}$ is the ODF computed from the fitted signal data
- $K^{+}$ is the pseudo-inverse kernel from `prediction_kernel`

Equivalently, this can be computed directly as $\mathbf{S}_\mathrm{pred} = \max(0, \mathbf{S}_\mathrm{data} \cdot (K_\mathrm{model}^T \cdot K^{+}))$ to avoid intermediate ODF calculation for efficiency.

The max operation ensures non-negative signal values.


## Testing Methodology

### `prediction_kernel` function tests

### Basic `predict` function tests

### Round trip `predict` function tests


## Capabilities and Applications

## Future Directions

## Conclusion

## Resources

### [DIPY tutorial repository](https://github.com/MadeInShineA/dipy-tutorial/tree/main){target="_blank"} notebooks

- [Reconstruct with Constant Solid Angle (Q-Ball)](./assets/notebooks/dipy-tutorial/reconstruct_with_csa_q_ball.html){target="_blank"}
- [Reconstruct with Generalized Q-Sampling Imaging](./assets/notebooks/dipy-tutorial/reconstruct_with_q_sampling_imaging_notebook.html){target="_blank"}
- [Introduction to Basic Tracking](./assets/notebooks/dipy-tutorial/basic_tracking_notebook.html){target="_blank"}

### [DIPY repository](https://github.com/MadeInShineA/dipy/tree/enh/gqi-predict-notebooks){target="_blank"} notebooks

- [GQI Roundtrip](./assets/notebooks/dipy/gqi_roundtrip_notebook.html){target="_blank"}
- [GQI Cross Voxel](./assets/notebooks/dipy/gqi_cross_voxel_notebook.html){target="_blank"}
- [GQI Unseen Data](./assets/notebooks/dipy/gqi_unseen_data_notebook.html){target="_blank"}


